package redis

import (
	"context"
	"fmt"
	"time"
)

const (
	// Maximum number of times to retry SetIfNotExists/CompareAndSwap operations
	// before returning an error.
	maxCASAttempts = 10
)

// A RateLimiterCtx manages limiting the rate of actions by key.
type RateLimiterCtx interface {
	RateLimitCtx(ctx context.Context, key string, quantity int) (bool, RateLimitResult, error)
}

// RateLimitResult represents the state of the RateLimiter for a
// given key at the time of the query. This state can be used, for
// example, to communicate information to the client via HTTP
// headers. Negative values indicate that the attribute is not
// relevant to the implementation or state.
type RateLimitResult struct {
	// Limit is the maximum number of requests that could be permitted
	// instantaneously for this key starting from an empty state. For
	// example, if a rate limiter allows 10 requests per second per
	// key, Limit would always be 10.
	Limit int

	// Remaining is the maximum number of requests that could be
	// permitted instantaneously for this key given the current
	// state. For example, if a rate limiter allows 10 requests per
	// second and has already received 6 requests for this key this
	// second, Remaining would be 4.
	Remaining int

	// ResetAfter is the time until the RateLimiter returns to its
	// initial state for a given key. For example, if a rate limiter
	// manages requests per second and received one request 200ms ago,
	// Reset would return 800ms. You can also think of this as the time
	// until Limit and Remaining will be equal.
	ResetAfter time.Duration

	// RetryAfter is the time until the next request will be permitted.
	// It should be -1 unless the rate limit has been exceeded.
	RetryAfter time.Duration
}

// GCRARateLimiterCtx is a RateLimiter that uses the generic cell-rate
// algorithm. The algorithm has been slightly modified from its usual
// form to support limiting with an additional quantity parameter, such
// as for limiting the number of bytes uploaded.
type GCRARateLimiterCtx struct {
	limit int

	// Think of the DVT as our flexibility:
	// How far can you deviate from the nominal equally spaced schedule?
	// If you like leaky buckets, think about it as the size of your bucket.
	delayVariationTolerance time.Duration

	// Think of the emission interval as the time between events
	// in the nominal equally spaced schedule. If you like leaky buckets,
	// think of it as how frequently the bucket leaks one unit.
	emissionInterval time.Duration

	store GCRAStoreCtx
}

// NewGCRARateLimiterCtx creates a GCRARateLimiterCtx
func NewGCRARateLimiter(st GCRAStoreCtx, quota RateQuota) (*GCRARateLimiterCtx, error) {
	if quota.MaxBurst < 0 {
		return nil, fmt.Errorf("invalid RateQuota %#v; MaxBurst must be greater than zero", quota)
	}
	if quota.MaxRate.period <= 0 {
		return nil, fmt.Errorf("invalid RateQuota %#v; MaxRate must be greater than zero", quota)
	}

	return &GCRARateLimiterCtx{
		delayVariationTolerance: quota.MaxRate.period * (time.Duration(quota.MaxBurst) + 1),
		emissionInterval:        quota.MaxRate.period,
		limit:                   quota.MaxBurst + 1,
		store:                   st,
	}, nil
}

// RateLimitCtx -
func (g *GCRARateLimiterCtx) RateLimitCtx(ctx context.Context, key string, quantity int) (bool, RateLimitResult, error) {
	var tat, newTat, now time.Time
	var ttl time.Duration
	rlc := RateLimitResult{Limit: g.limit, RetryAfter: -1}
	limited := false

	var err error
	var tatVal int64
	var updated bool

	// tat refers to the theoretical arrival time that would be expected
	// from equally spaced requests at exactly the rate limit.
	tatVal, now, err = g.store.GetWithTime(ctx, key)
	if err != nil {
		return false, rlc, err
	}

	if tatVal == -1 {
		tat = now
	} else {
		tat = time.Unix(0, tatVal)
	}

	increment := time.Duration(quantity) * g.emissionInterval
	if now.After(tat) {
		newTat = now.Add(increment)
	} else {
		newTat = tat.Add(increment)
	}

	// Block the request if the next permitted time is in the future
	allowAt := newTat.Add(-(g.delayVariationTolerance))
	if diff := now.Sub(allowAt); diff < 0 {
		if increment <= g.delayVariationTolerance {
			rlc.RetryAfter = -diff
			ttl = tat.Sub(now)
		}
		limited = true
		break
	}

	ttl = newTat.Sub(now)

	if tatVal == -1 {
		updated, err = g.store.SetIfNotExistsWithTTL(ctx, key, newTat.UnixNano(), ttl)
	} else {
		updated, err = g.store.CompareAndSwapWithTTL(ctx, key, tatVal, newTat.UnixNano(), ttl)
	}

	if err != nil {
		return false, rlc, err
	}
	if updated {
		break
	}

	next := g.delayVariationTolerance - ttl
	if next > -g.emissionInterval {
		rlc.Remaining = int(next / g.emissionInterval)
	}
	rlc.ResetAfter = ttl

	return limited, rlc, nil
}
